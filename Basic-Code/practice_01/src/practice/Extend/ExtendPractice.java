package practice.Extend;

//在继承的关系中，子类就是一个父类

//定义父类的格式，就是定义一个普通的类
//public class 父类名称 {
// ...成员参数
// }

//定义子类的格式
//public class 子类名称 extends 父类名称 {
// }

/*在父子类继承关系中，如果成员变量重名，在创建子类对象时，访问有两种方式
* 1.直接通过子类对象访问成员变量；规则：等号左边是谁，就优先用谁，没有就向上找，也就是先找定义的类中是否有要找的成员变量，没有再去寻找父类
* 2.间接通过成员方法访问成员变量；规则：成员方法属于谁，就优先用谁，没有则向上找
* */


/*在父子类继承关系中，访问成员方法的规则，如果成员方法重名，那么创建对象的类是谁，就优先使用谁的成员方法，没有则向上找
*
* */

/*类中成员方法的局部变量 在成员方法中直接写，
，和类的成员变量，在成员方法中使用this.成员变量名
和类的父类成员变量重名，在成员方法中使用super.成员变量名
*/

//注意事项
/*
* 1.无论是成员变量还是成员方法，只要在自身的类中找不到，就向上去找父类中，但是父类不会向下找子类
* */
//==========================================================================================================================
//抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束
//抽象类：抽象方法所在的类，必须是抽象类才可以。在class之前写上abstract即可。

/*
* 如何使用抽象类和抽象方法
* 1.不能直接创建抽象类对象
* 2.必须用一个子类来继承抽象父类
* 3.子类必须覆盖重写所有父类的抽象方法
* 4.创建子类对象进行使用
*
* 注意事项：
* 1.抽象类不能创建对象，只能由其非抽象子类创建对象
* 2.抽象类可以有构造方法，供子类在创建对象时，初始化父类成员使用
* 3.抽象类中不一定有抽象方法，但是抽象方法必须在抽象类中(一个抽象类不一定含有抽象方法，这样的类也不能直接创建对象，在一些特殊场景下有用途)
* 4.抽象类的子类，必须覆盖重写父类中的所有抽象方法
*
* */

public abstract class ExtendPractice {
    public abstract void eat();//这就是一个抽象方法，具体吃什么不确定(参数不确定)；
    public void normalMethod() {
//        普通的成员方法
    }
}
